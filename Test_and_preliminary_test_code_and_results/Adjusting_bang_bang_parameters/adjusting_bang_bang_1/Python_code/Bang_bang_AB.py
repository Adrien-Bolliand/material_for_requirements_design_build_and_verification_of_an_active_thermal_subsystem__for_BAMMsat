 # Description:
 #  The bang bang class is bang bang regulator (https://en.wikipedia.org/wiki/Bang-bang_control)
 #  Modified to have two steps, see sketch below.
 #  It has been written for BAMMsat on BEXUS flight on the BEXUS 30
 #  Writen by Adrien Bolliand
 #
 # list of attributs:
  # list           (list of str) logs the all the bang bang object at initialisation
  # log            (list of str) log with all the status of the controler at all the updates
  # name           (string) example "ring heater for flight mode"
  # heater         (Heater object) the heater object corresponding to the physical heater that the bang bang is regulating 
  # PWM_GPIO       (digital PWM pin) output pi to the heater driver as a PWM signal
  # PWM_ex_high    (int) extreme high duty cycle of the PWM between 0 and 100 when temperature lower than the thresh_ex_low
  # PWM_high       (int) high duty cycle of the PWM between 0 and 100
  # PWM_low        (int) low duty cycle for PWM (should be 0) between 0 and 100
  # PWM_ex_high    (int) extreme low duty cycle of the PWM between 0 and 100 when temperature lower than the thresh_ex_high
  # thresh_ex_high (float) in CELCIUS extreme high temperature thershold ==> PWM of heater set as PWM_ex_low. (0 % by default, heater turned off)
  # thresh_high    (float) in CELCIUS high terature limit ==>  PWM of heater set as PWM_low (10 % by default)
  # thresh_low     (float) in CLECIUS low temperature limit ==> PWM of heater set as PWM_hight (90 % by default)
  # thersh_ex_low  (float) in CLECIUS extreme low temperature ==> PWM of heater set as PWM_ex_high (100 % by default)
  # mem            (boolean) to know if heater should be ON or OFF in the hysteresis
  # T              (float) in CELCIUS last Temperature to given to the controller
  # energy         (float) in Watts, energy counsumption of the heater at the moment of the update
 #
 # list of methods:
  # __init__(name, PWM_GPIO, PWM_value_low, PWM__value_high, Thres_value_low, Thres_value_high) build the controller. it will output a PWM on the selected output PWM pin
  # update (Temperature) given the temperature, the controller will change or not the value of the PWM output
  # logging()            generate the logg text
 #
 # 
 #           PWM
 #            /\
 #       _____|____  - - - - - - - - - - - - - - - - - - - - - - PWM_ex_high
 #            |    | 
 #            |    |
 #            |    |_____<>____ _____>_____ - - - - - - - - - -  PWM_high 
 #            |               |           |
 #            |               |           |
 #            |               /\          \/ 
 #            |               |           |
 #            |               |           |
 #            |               |           |           
 #            |               |_____<_____|___<>_____  - - - - - PWM_low
 #            |                                     |
 #            |                                     |
 #            |                                     |_______ - - PWM_ex_low
 #       -----|----|----------|-----------|---------|--------------------------> Temperature (°C)
 #         thres_ex_low   thres_low   thres_high  thres_ex_high
 #                 |          |           |         |
 # self.mem = True     True                  False       False
 #                            ==>  True  ==>
 #                            <== False <==



import pigpio

from datetime import datetime

class Bang_bang:
    list = []
    log = [] # varible hosting all the loggs text generated by the method logging()

    def __init__( self, pi, name, heater, PWM_pin,
                PWM_value_extreme_low = 0, PWM_value_low = 20, PWM__value_high = 90, PWM_value_extreme_high = 100,
                Thres_extreme_low = 18.5, Thres_value_low = 19, Thres_value_high = 21, Thres_extreme_high = 21.5,
                frequency_pwm = 320):
        self.name = name
        self.heater = heater
        self.PWM_pin = PWM_pin
        self.PWM_frequency   = frequency_pwm # 8000  4000  2000 1600 1000  800  500  400  320
        self.PWM_low    = PWM_value_low
        self.PWM_high   = PWM__value_high
        self.PWM_ex_low  = PWM_value_extreme_low
        self.PWM_ex_high = PWM_value_extreme_high
        self.thres_low  = Thres_value_low
        self.thres_high = Thres_value_high
        self.thres_ex_low  = Thres_extreme_low
        self.thres_ex_high = Thres_extreme_high 
        self.mem        = True
        self.PWM_value  = None
        self.T          = None
        self.energy     = 0
        self.pigpio = pi
        self.pigpio.set_PWM_range(self.PWM_pin, 100) # PWM value between 0 and 100
        self.pigpio.set_PWM_frequency(self.PWM_pin, self.PWM_frequency)
        Bang_bang.list.append("Bang-Bang {0} at pin {1} with Thershold values at: {4}/{5} and PWM values at: {2}/{3}.  ".format(self.name,self.PWM_pin,self.PWM_high,self.PWM_low,self.thres_high,self.thres_low))

 
    def update (self, Temperature):
        if Temperature == None:
            Bang_bang.log.append("Temperature not read, Bang bang not updated")
            return    
        
        self.T = Temperature ## update the temperature attribute

        ## if temerature is extreme low or high
        if Temperature > self.thres_ex_high or Temperature < self.thres_ex_low : ## if temerature is extreme low or high
            if Temperature < self.thres_ex_low:
                self.pigpio.set_PWM_dutycycle(self.PWM_pin, self.PWM_ex_high) ## Set GPIO PWM to extreme HIGH
                self.PWM_value = self.pigpio.get_PWM_dutycycle(self.PWM_pin) # Update the PWM value for report in the loggs
                self.mem = True # update memory to True. the system in on the left side of hysteresis (high side of the hysteris)
            else:
                self.pigpio.set_PWM_dutycycle(self.PWM_pin, self.PWM_ex_low)  ## Set GPIO PWM to extreme low
                self.PWM_value = self.pigpio.get_PWM_dutycycle(self.PWM_pin) # Update the PWM value for report in the loggs
                self.mem = False # update memory to False. the system in on the right side of hysteresis (low side of the hysteris)
            #self.logging()
            self.energy = (self.PWM_value * 0.01 * self.heater.voltage_in **2) /self.heater.resistor # Compute the energy consumption after the upddate: E = PWM * U^2 / R
            return

        ## arrives here if temperature is not extreme ==> T < thers_ex_high OR T > Thersh_ex_low)
        if self.mem:
            if Temperature > self.thres_high:
                self.mem = False # update memory to False. the system in on the right side of hysteresis (low side of the hysteris)
        else:
            if Temperature < self.thres_low:
                self.mem = True # update memory to high. the system in on the right side of hysteresis (low side of the hysteris)

        ## Set the power to the heater when temperature is not extreme
        if self.mem:
            self.pigpio.set_PWM_dutycycle(self.PWM_pin, self.PWM_high)  ## Set GPIO PWM to high
            self.PWM_value = self.pigpio.get_PWM_dutycycle(self.PWM_pin) # Update the PWM value for report in the loggs
        else:
            self.pigpio.set_PWM_dutycycle(self.PWM_pin, self.PWM_low)  ## Set GPIO PWM to low
            self.PWM_value = self.pigpio.get_PWM_dutycycle(self.PWM_pin) # Update the PWM value for report in the loggs

        self.energy = (self.PWM_value * 0.01 * self.heater.voltage_in **2) /self.heater.resistor # Compute the energy consumption after the upddate: E = PWM * U^2 / R

        self.logging()


    def logging(self):
        # this function generate a text with the bang bang status for repporting
         Bang_bang.log.append("{7} :  Bang-Bang {0}  Heating Satus: {5}, PWM value: {8} at Temperature {6} °C. Thershold values at: {3}/{4} and PWM values at: {1}/{2}.  ".format(self.name,self.PWM_high,self.PWM_low,self.thres_high,self.thres_low, self.mem, self.T,datetime.now().strftime("%Y-%m-%d_%H-%M-%S"), self.PWM_value))